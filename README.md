# GIT

*Git* — это система контроля версий, которая помогает отслеживать изменения в проекте. Этот инструмент можно использовать как для индивидуальной, так и для командной работы.

## Начало работы

### Инициализируем репозиторий

В корневой папке нашего проекта выполняем команду:
```bash
git init
```

В подпапке .git Git будет хранить всю служебную информацию.

Если ошиблись папкой или по какой-то причине нужно отключить/удалить контроль версий, поможет следующая команда, она полностью удалит папку git из репозитория:
```bash
rm -rf .git
```

Проверить состояние репозитория:
```bash
git status
```


### Добавляем файлы в репозиторий

Подготовить файлы к сохранению, указывается конкретный файл (filename), или вся папка (.), или весь репозиторий (--all):
```bash
git add
```

Команда git add не сохраняет содержимое файлов в репозитории. Само сохранение, или фиксацию состояния файлов, называют коммитом (от англ. commit — «совершать», «фиксировать»). «Сделать коммит» значит сохранить текущую версию файла. 


### Делаем коммит

Коммит — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться». 

Выполнить коммит:
```bash
git commit -m'message'
```

Коммит нужно описывать так, чтобы было понятно, какие именно изменения были сделаны!


### История коммитов

Посмотреть история коммитов, последние коммиты показываются первыми сверху:
```bash
git log
```


## Синхронизация

### SSH

Когда компьютеры обмениваются данными в сети, они следуют сетевым протоколам (англ. network protocols) — правилам обмена данными между компьютерами.
Один из наиболее распространённых сетевых протоколов — SSH (от англ. Secure Shell Protocol). Он обеспечивает безопасный обмен данными в сети. С помощью этого протокола можно получать данные с удалённого компьютера или отправлять их на него. Трафик шифруется, поэтому протокол безопасен.
SSH использует пару ключей для обеспечения безопасности — публичный и приватный:

* Приватный ключ (англ. private key) хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.
* Публичный ключ (англ. public key) доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.

Только вы можете расшифровать данные с помощью приватного ключа, но любой владелец публичного ключа может их для вас зашифровать. Эти два ключа связаны и образуют SSH-пару. В будущем вы наверняка будете использовать их для взаимодействия с GitHub и другими удалёнными серверами.

Cоздаём SSH-ключ в домашнем каталоге, проверяем его наличие в папке и выводим на экран для копирования:
```bash
cd ~
ssh-keygen
ls -a ~/.ssh 
cat ~/.ssh/id_rsa.pub
```

Файл с расширением .pub — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому!

В настройках аккаунта GitHub вставляем показанный ключ и сохраняем, теперь мы можем подключаться к удалённому репозиторию по SSH.

Затем проверим ключ, подключившись к серверу GitHub командой:
```bash
ssh -T git@github.com
```


### Связываем локальный и удалённый репозитории

На GitHub создаём пустой репозиторий, копируем url SSH и привязываем к локальному из папки репозитория:
```bash
git remote add origin <url>
```


*origin* (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). Это значительно упрощает работу.

Убедимся, что репозитории связаны:
```bash
git remote -v
```

### Синхронизируем локальный и удалённый репозитории

В репозитории может существовать сразу несколько веток — параллельных историй изменений. Также они могут соединяться друг с другом.

Отправить изменения на удалённый репозиторий:
```bash
git push
```

В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой.

Если удалённая и локальная ветки разошлись, то можно выполнить 'rebase' или:
```bash
git push --force
```

Но в этом случае git просто удалит лишний коммит и запишет следующие.

На другом компьютере можно скачать этот репозиторий и продолжить работу.
```bash
git clone <url>
```

Забрать изменения из удалённого репозитория:
```bash
git pull
```


### README

Чтобы другие пользователи, а также потенциальные клиенты или работодатели могли понять, что представляет собой проект, его нужно описать. Такое описание принято указывать в файле README.md.

Преимущество README.md в том, что средства командной работы (такие, как GitHub) могут отображать его содержимое в браузере в виде удобной разметки. Для этого нужно не просто залить текст, но и настроить шрифт, заголовки и отступы с помощью *markdown*.

[Шпаргалка по Markdown 1](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c "Шпаргалка по Markdown 1")

[Шпаргалка по Markdown 2](https://www.markdownguide.org/cheat-sheet/ "Шпаргалка по Markdown 2")


## Навигация и статусы

### Хэш

Хеширование (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.

Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.

Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0—9 и латинских букв A—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:

* если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
* если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

### Лог

После вызова *git log* появляется список коммитов.

Разберём элементы, из которых состоит описание:

* строка из цифр и латинских букв после слова commit — это хеш коммита;
* Author — имя автора и его электронная почта;
* Date — дата и время создания коммита;
* в конце находится сообщение коммита.

Получить сокращённый лог:
```bash
git log --oneline
```

Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда *git log --oneline* автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

Вывод в виде графа:
```bash
git log --graph
```


### HEAD

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).

Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.

### Статусы

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

* untracked (англ. «неотслеживаемый») - Git «видит», что такой файл существует, но не следит за изменениями в нём.
* staged (англ. «подготовленный») - после выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит.
* tracked (англ. «отслеживаемый») - в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.
* modified (англ. «изменённый») - означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия.

```mermaid
graph LR;
  untracked -- "git add" --> staged;
  staged    -- "git commit"     --> tracked/comitted;
  tracked/comitted -- "изменения" --> modified;
  modified -- "git add" --> staged;
  staged -- "изменения" --> modified;
  staged    -- "git commit"     --> tracked/comitted.
```


## Работа над ошибками

### Сообщения к коммитам

В разных командах есть свои правила сообщений коммитов, но есть общие принципы описания.

Например, в выводе команды *git log --oneline* умещается максимум 72 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов».

Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:

* относительно коротким, чтобы его было легко прочитать;
* информативным.

Чтобы упростить работу, команды или даже целые компании часто договариваются об определённом стиле (то есть о правилах) оформления сообщений коммитов.

Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, LGS-239 значит, что это 239-я задача в проекте LGS (сокращение от англ. logistics — «логистика»).  
В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.

Стандарт **Conventional Commits** (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. Использовать его для других типов проектов (например, для перевода книги) было бы неудобно.

Conventional Commits предлагает такой формат коммита: <type>: <сообщение>.  
Первая часть type — это тип изменений. Таких типов достаточно много. Вот два примера:
* feat (сокращение от англ. feature) — для новой функциональности;
* fix (от англ. «исправить», «устранить») — для исправленных ошибок.

**GitHub** можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать #<номер задачи>. В таком случае GitHub свяжет коммит и задачу.

Для сообщений на русском языке часто рекомендуют использовать инфинитивы. Например: Исправить ошибку #123.  
Для сообщений на английском рекомендуется использовать повелительное наклонение (англ. imperative). Например: Use library mega_lib_300, Fix exit button.  
Эти рекомендации сложились исторически, и им следуют многие проекты.

### Редактирование коммитов

Иногда в только что выполненном коммите нужно что-то поменять. В таком случае можно внести правки в уже сделанный коммит с помощью опции --amend (от англ. amend — «исправить», «дополнить») у команды commit. Опция --amend работает только с последним коммитом (HEAD).

Дополнить коммит новыми файлами:
```bash
git add <filename>
git commit --amend --no-edit
```

С опцией --amend команда commit не создаст новый коммит, а дополнит последний, просто добавив в него файл. Опция --no-edit сообщает команде commit, что сообщение коммита нужно оставить как было.

Изменить сообщение коммита:
```bash
git commit --amend -m "Новое сообщение"
```

Выполнить unstage изменений файла (filename) или папки (.):
```bash
git restore --staged <filename>
```

«Откатить» коммит:
```bash
git reset --hard <commit hash>
```

Git перейдёт в состояние указанного коммита и удалит все последующие коммиты и сохранённые состояния. Будьте осторожны!

«Откатить» изменения (modified), которые не попали ни в staging, ни в коммит:
```bash
git restore <file>
```

Изменения в файле «откатятся» до последней версии, которая была сохранена через git commit или git add.


## Изменения и игнорирования

Посмотреть изменения между закомиченной и модифицированной версией файла:
```bash
git diff
```

Git покажет различия между 2-мя коммитами:
```bash
git diff <commit hash> <commit hash>
```

* - красный цвет строки значит, что эта строка была удалена;
* + зелёный цвет строки значит, что она была добавлена.

Остальные строки вывода команды:
* Первые две строки (diff --git a/... b/... и index 901da07..ac459e1 100644) — это низкоуровневая техническая информация.
* Строки --- a/... и +++ b/... говорят, что дальше будет выведен результат сравнения файлов a/... и b/... — исходной и текущей версий.
* Строка @@ -1,2 +1,2 @@ сообщает, какие строки файла попали в сравнение. Выражение 1,2 (неважно, с плюсом или с минусом) говорит, что были использованы две строки, начиная с первой. Если бы было, например, написано +15,7, это значило бы, что в сравнении участвуют 7 строк, начиная с 15-й.

Чтобы просмотреть изменения в staged (после команды git add):
```bash
git diff --staged
```

### Игнорирование

Часто бывает так, что в папке-репозитории есть файлы, для которых не нужно хранить историю изменений. Чтобы Git игнорировал такие файлы и не пытался добавить их в репозиторий, нужно создать файл .gitignore (от англ. ignore — «игнорировать») и записать в него названия игнорируемых файлов.

.gitignore — это обычный текстовый файл. Его добавляют в корень репозитория и тоже коммитят. В простейшем случае в .gitignore указывают все файлы, которые нужно игнорировать (по одному имени на строку). Но часто удобнее использовать шаблоны.

Правила из .gitignore применяются только к новым (untracked) файлам. Если файл уже попал в staging area или в коммит, то правила на него не распространяются.

**Шаблоны:**

* Если строка начинается с #, то это комментарий, и .gitignore не будет его учитывать;
* Символ звёздочки (*) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне в .gitignore, значит, файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки;
* Вопросительный знак ? соответствует одному любому символу;
* Квадратные скобки ([..]), как и вопросительный знак, соответствуют одному символу. При этом символ не любой, а только из списка, который указан в скобках;
* Косая черта, или слеш (/), указывает на каталоги. Если шаблон в .gitignore начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории;
* Функция парных звёздочек (**) похожа на функцию одинарной (*). Отличие в том, как они работают с вложенными папками. Двойная звёздочка может соответствовать любому количеству таких папок (в том числе нулю). Одинарная может соответствовать только одной;
* Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).

Игнорируемые файлы не отображаются в выводе команды git status, иначе они бы засоряли вывод.  
Если всё же нужно отобразить все игнорируемые файлы, то это можно сделать с помощью ключа:
```bash
git status --ignored
```


## Ветки

Просмотреть ветки проекта (с флагом '-a' покажет все известные ветки, как локальные, так и удалённые):
```bash
git branch
```

Выводятся ветки, которые есть в проекте. Звёздочкой (*) отмечено, в какой ветке вы находитесь в текущий момент.

Создать ветку:
```bash
git branch <название_ветки>
```

Создать ветку и перейти в неё (без флага '-b' - просто переход между ветками):
```bash
git checkout -b <название_ветки>
```

Есть разные подходы к наименованию веток. Но независимо от подхода ветки нужно называть так, чтобы другим участникам было понятно, что в них происходит. Можно использовать указатели feature (англ. «особенность», «деталь») для веток, где прорабатывается новая функциональность, и bugfix (от англ. bug — «жук», «ошибка» и fix — «исправить») для веток, где ведётся работа по исправлению ошибок.

Сравнить ветки:
```bash
git diff <название_ветки1> <название_ветки2>
```

Сравнивать хеши комитов может быть неудобно, для облегчения этой задачи в Git есть суффикс навигации ~N, где N — это число. Он отсчитывает от заданного коммита N коммитов назад во времени. Нумерация начинается с нуля: commit~0 — это сам коммит, commit~1 — предыдущий, commit~2 — предшествующий предыдущему и так далее.  
На практике чаще нужен либо текущий коммит (HEAD), либо следующий за ним (HEAD~1). Для ~1 есть специальное сокращение ~ (без числа). То есть вместо HEAD~1 обычно пишут просто HEAD~.

Выполнить слияние:
```bash
git merge <название_ветки>
```

Перед тем как начать процесс слияния, нужно перейти в ветку, куда должны добавиться изменения. Перейдите в неё и вызовите команду git merge с именем присоединяемой ветки в качестве параметра.

Fast-forward слияние веток можно отключить флагом '--no-ff'. Также его можно отключить «навсегда» (до тех пор, пока вы не вернёте настройку «как было») с помощью настройки merge.ff:
```bash
git config [--global] merge.ff false.
```

Если отключить слияние в режиме fast-forward, вместо «перемотки» ветки Git создаст в ней коммит слияния (англ. merge commit) — в обиходе его называют merge-коммит.

Удалить ветку после объединения:
```bash
git branch -D <название_ветки>
```

У команды есть более безопасный вариант с флагом '-d'. Он удалит ветку только если две ветки стали (или изначально были) частью одной истории.

Перед созданием нового пул-реквеста считается хорошей практикой перейти в главную ветку, «подтянуть» в неё изменения, а затем добавить эти изменения в вашу ветку с помощью git merge main.

### Конфликт

Если Git не может провести слияние изменений автоматически, он сообщает о конфликте. Конфликт — это ситуация, в которой один или несколько человек модифицировали один и тот же файл. При этом результаты таких модификаций оказались несовместимы и разобраться в том, какой из вариантов правильный, может только человек.


## **В случае пожара** :fire::fire::fire:

1. git add --all
2. git commit -m'message'
3. git push

PROFIT!!!